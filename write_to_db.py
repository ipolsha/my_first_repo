# -*- coding: utf-8 -*-
"""write_to_db.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-w6o13GkjJhiY-o8PT2GOQFI8HJgQZvw
"""

import sqlite3
import os

def step1_get_credentials():
    """Пункт 1: Получаем учетные данные из SQLite базы access"""

    print("=" * 60)
    print("ШАГ 1: Получение учетных данных из creds.db")
    print("=" * 60)

    try:
        # Подключаемся к SQLite базе
        conn = sqlite3.connect('creds.db')
        cursor = conn.cursor()
        print("Подключение к SQLite установлено")

        # Смотрим какие таблицы есть в базе
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        print(f"Найдены таблицы: {tables}")

        # Исследуем таблицу access
        table_name = 'access'
        print(f"\nИсследуем таблицу '{table_name}':")

        # Смотрим структуру таблицы
        cursor.execute(f"PRAGMA table_info({table_name})")
        columns = cursor.fetchall()
        print("Структура таблицы:")
        for col in columns:
            print(f"  - {col[1]} ({col[2]})")

        # Получаем данные из таблицы
        cursor.execute(f"SELECT * FROM {table_name}")
        rows = cursor.fetchall()

        print(f"\nДанные в таблице ({len(rows)} строк):")
        for i, row in enumerate(rows, 1):
            # Маскируем пароль для безопасности
            masked_row = list(row)
            if len(masked_row) > 3:  # Если есть поле с паролем
                masked_row[3] = "***"  # Маскируем пароль
            print(f"  Строка {i}: {masked_row}")

        # Берем первую строку (предполагаем, что она одна)
        if rows:
            first_row = rows[0]
            print(f"\nИспользуем данные из строки 1")

            # Создаем словарь с учетными данными
            credentials = {
                'host': first_row[0],      # url
                'port': first_row[1],      # port
                'user': first_row[2],      # user
                'password': first_row[3],  # pass
                'database': 'homeworks'    # из условия задания
            }

            # Выводим полученные данные (без пароля)
            safe_creds = credentials.copy()
            safe_creds['password'] = '***'
            print("\nУчетные данные получены:")
            for key, value in safe_creds.items():
                print(f"  {key}: {value}")

            conn.close()
            return credentials
        else:
            print("В таблице нет данных!")
            conn.close()
            return None

    except sqlite3.Error as e:
        print(f"Ошибка SQLite: {e}")
        return None
    except Exception as e:
        print(f"Общая ошибка: {e}")
        return None

def test_credentials(credentials):
    """Проверяем что мы правильно получили данные"""
    print("\n" + "=" * 40)
    print("ТЕСТИРОВАНИЕ ПОЛУЧЕННЫХ ДАННЫХ")
    print("=" * 40)

    if credentials:
        required_fields = ['host', 'port', 'user', 'password', 'database']
        missing_fields = [field for field in required_fields if field not in credentials]

        if missing_fields:
            print(f"Отсутствуют поля: {missing_fields}")
            return False
        else:
            print("Все необходимые поля присутствуют")
            print("Данные готовы для подключения к PostgreSQL")
            return True
    else:
        print("Учетные данные не получены")
        return False

import psycopg2


def step2_connect_postgresql(credentials):
    """Пункт 2: Подключаемся к PostgreSQL базе homeworks"""

    print("=" * 60)
    print("ШАГ 2: Подключение к PostgreSQL базе homeworks")
    print("=" * 60)

    if not credentials:
        print("Нет учетных данных для подключения")
        return None

    try:
        # Показываем параметры подключения (без пароля)
        safe_creds = credentials.copy()
        safe_creds['password'] = '***'
        print("Параметры подключения:")
        print(f"  Хост: {safe_creds['host']}")
        print(f"  Порт: {safe_creds['port']}")
        print(f"  Пользователь: {safe_creds['user']}")
        print(f"  База данных: {safe_creds['database']}")

        print("\nПытаемся подключиться к PostgreSQL...")

        # Подключаемся к PostgreSQL
        conn = psycopg2.connect(
            host=credentials['host'],
            port=credentials['port'],
            user=credentials['user'],
            password=credentials['password'],
            database=credentials['database']
        )

        print("Подключение к PostgreSQL установлено!")

        # Создаем курсор для выполнения запросов
        cursor = conn.cursor()

        # 1. Проверяем версию PostgreSQL
        cursor.execute("SELECT version();")
        version_info = cursor.fetchone()[0]
        print(f"Версия PostgreSQL: {version_info.split(',')[0]}")

        # 2. Проверяем текущую базу данных
        cursor.execute("SELECT current_database();")
        current_db = cursor.fetchone()[0]
        print(f"Текущая база данных: {current_db}")

        # 3. Проверяем схему (должна быть public)
        cursor.execute("SELECT current_schema();")
        current_schema = cursor.fetchone()[0]
        print(f"Текущая схема: {current_schema}")

        # 4. Проверяем доступные таблицы в схеме public
        cursor.execute("""
            SELECT table_name
            FROM information_schema.tables
            WHERE table_schema = 'public'
            ORDER BY table_name;
        """)
        tables = cursor.fetchall()

        print(f"\nТаблицы в схеме public ({len(tables)} шт.):")
        for table in tables:
            print(f"  - {table[0]}")

        # 5. Проверяем права пользователя
        cursor.execute("SELECT current_user;")
        current_user = cursor.fetchone()[0]
        print(f"Текущий пользователь: {current_user}")

        # Закрываем соединение
        cursor.close()
        conn.close()
        print("\nСоединение с PostgreSQL закрыто")

        return True

    except psycopg2.OperationalError as e:
        print(f"Ошибка подключения к PostgreSQL: {e}")
        return False

    except psycopg2.Error as e:
        print(f"Ошибка PostgreSQL: {e}")
        return False

    except Exception as e:
        print(f"Неожиданная ошибка: {e}")
        return False

import psycopg2
import pandas as pd


def load_your_dataset():
    print('Загрузка датасета')

    df = pd.read_csv('/content/new_data.csv', index_col=0)

    print(f"Загружено {len(df)} строк")
    print(f"Колонки: {list(df.columns)}")
    print("\nПервые 3 строки датасета:")
    print(df.head(3))

    return df

def create_table_structure(df, table_name):

    print(f"\nСоздаем структуру для таблицы '{table_name}'...")

    # Автоматически определяем типы данных Pandas -> PostgreSQL
    type_mapping = {
        'int64': 'INTEGER',
        'float64': 'REAL',
        'object': 'VARCHAR(255)',
        'bool': 'BOOLEAN',
        'datetime64[ns]': 'TIMESTAMP'
    }

    columns_sql = []
    for column, dtype in df.dtypes.items():
        pg_type = type_mapping.get(str(dtype), 'VARCHAR(255)')
        # Экранируем названия колонок с пробелами и специальными символами
        escaped_column = f'"{column}"' if ' ' in column or '-' in column else column
        columns_sql.append(f"{escaped_column} {pg_type}")

    create_table_sql = f"""
    CREATE TABLE IF NOT EXISTS {table_name} (
        {', '.join(columns_sql)}
    );
    """

    print("Структура таблицы определена:")
    for col in columns_sql:
        print(f"  - {col}")

    return create_table_sql

def step3_write_to_postgres(credentials, df, table_name):
    """Пункт 3: Записываем данные в PostgreSQL"""

    print("=" * 60)
    print(f"Запись данных в таблицу {table_name}")
    print("=" * 60)

    if df is None or len(df) == 0:
        print("Нет данных для записи")
        return False

    try:
        # Подключаемся к PostgreSQL
        conn = psycopg2.connect(**credentials)
        cursor = conn.cursor()

        print("Подключение к PostgreSQL установлено")

        # 1. Создаем таблицу
        create_sql = create_table_structure(df, table_name)
        cursor.execute(create_sql)
        print("Таблица создана/проверена")

        # 2. Очищаем таблицу (если она уже существовала)
        cursor.execute(f"TRUNCATE TABLE {table_name}")
        print("Таблица очищена")

        # 3. Записываем данные (максимум 100 строк)
        data_to_insert = df.head(100)
        print(f"Записываем {len(data_to_insert)} строк...")

        # Подготавливаем SQL для вставки (экранируем названия колонок)
        columns = ', '.join([f'"{col}"' if ' ' in col or '-' in col else col for col in df.columns])
        placeholders = ', '.join(['%s'] * len(df.columns))
        insert_sql = f"INSERT INTO {table_name} ({columns}) VALUES ({placeholders})"

        # Вставляем данные построчно
        for index, row in data_to_insert.iterrows():
            cursor.execute(insert_sql, tuple(row))

        # Подтверждаем изменения
        conn.commit()
        print("Данные записаны в базу")

        # 4. Проверяем запись
        cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
        count_in_db = cursor.fetchone()[0]
        print(f"В таблице теперь {count_in_db} строк")

        # 5. Показываем пример записанных данных
        cursor.execute(f"SELECT * FROM {table_name} LIMIT 3")
        sample_data = cursor.fetchall()

        print(f"\nПример записанных данных (первые 3 строки):")
        # Показываем названия колонок
        cursor.execute(f"SELECT column_name FROM information_schema.columns WHERE table_name = '{table_name}' ORDER BY ordinal_position")
        column_names = [col[0] for col in cursor.fetchall()]
        print(f"Колонки: {column_names}")

        for i, row in enumerate(sample_data, 1):
            print(f"  Строка {i}: {row}")

        # 6. Проверяем, что таблица видна в списке
        cursor.execute("""
            SELECT table_name
            FROM information_schema.tables
            WHERE table_schema = 'public'
            AND table_name = %s
        """, (table_name,))

        table_exists = cursor.fetchone() is not None

        if table_exists:
            print(f"\nТаблица '{table_name}' успешно создана в схеме public")
        else:
            print(f"\nТаблица '{table_name}' не найдена в схеме public")

        cursor.close()
        conn.close()

        return True

    except psycopg2.Error as e:
        print(f"Ошибка PostgreSQL: {e}")
        return False
    except Exception as e:
        print(f"Общая ошибка: {e}")
        return False

def verify_table_creation(credentials, table_name):
    """Проверяем, что таблица создана и доступна"""

    print("\n" + "=" * 40)
    print("ПРОВЕРКА СОЗДАНИЯ ТАБЛИЦЫ")
    print("=" * 40)

    try:
        conn = psycopg2.connect(**credentials)
        cursor = conn.cursor()

        # Проверяем структуру созданной таблицы
        cursor.execute("""
            SELECT column_name, data_type
            FROM information_schema.columns
            WHERE table_name = %s
            ORDER BY ordinal_position
        """, (table_name,))

        columns = cursor.fetchall()

        if columns:
            print(f"Таблица '{table_name}' создана успешно!")
            print(f"Структура таблицы ({len(columns)} колонок):")
            for col_name, data_type in columns:
                print(f"  - {col_name} ({data_type})")
        else:
            print(f"Таблица '{table_name}' не найдена")
            return False

        # Проверяем количество данных
        cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
        row_count = cursor.fetchone()[0]
        print(f"Количество строк в таблице: {row_count}")


        return True

    except Exception as e:
        print(f"Ошибка при проверке таблицы: {e}")
        return False

if __name__ == "__main__":
    # Получаем учетные данные
    print("Получаем учетные данные...")
    credentials = step1_get_credentials()

    if not credentials:
        print("Не удалось получить учетные данные")
        exit(1)

    # Загружаем датасет
    df = load_your_dataset()

    if df is None or len(df) == 0:
        print("Не удалось загрузить датасет")
        exit(1)

    # Определяем название таблицы
    table_name = "greskova"

    print(f"\nБудем использовать таблицу: {table_name}")

    # Выполняем пункт 3
    success = step3_write_to_postgres(credentials, df, table_name)

    if success:
        # Проверяем создание таблицы
        verification = verify_table_creation(credentials, table_name)

        if verification:
            print("ПУНКТ 3 ВЫПОЛНЕН!")
            print(f"Таблица '{table_name}' создана в схеме public")
            print(f"Данные записаны (максимум 100 строк)")
            print(f"Структура соответствует датасету")